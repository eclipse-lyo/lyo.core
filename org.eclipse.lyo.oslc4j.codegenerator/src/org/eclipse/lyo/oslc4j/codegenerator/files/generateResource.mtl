[comment encoding = UTF-8 /]
[comment
/*******************************************************************************
 * Copyright (c) 2012 IBM Corporation and others.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v. 1.0 which accompanies this distribution.
 *  
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *
 *     Russell Boykin       - initial API and implementation
 *     Alberto Giammaria    - initial API and implementation
 *     Chris Peters         - initial API and implementation
 *     Gianluca Bernardini  - initial API and implementation
 *	   Sam Padgett	       - initial API and implementation
 *     Michael Fiedler     - adapted for OSLC4J
 *     Jad El-khoury        - initial implementation of code generator (https://bugs.eclipse.org/bugs/show_bug.cgi?id=422448)
 *******************************************************************************/
/]

[module generateResource('org.eclipse.lyo.oslc4j.adaptorInterface')]

[import org::eclipse::lyo::oslc4j::codegenerator::services::services/]
[import org::eclipse::lyo::oslc4j::codegenerator::services::resourceServices/]
[import org::eclipse::lyo::oslc4j::codegenerator::services::resourcePropertyServices/]
[import org::eclipse::lyo::oslc4j::codegenerator::services::adaptorInterfaceServices/]

[template public generateResource(aResource : Resource)]
[file (javaClassFullFileName(aResource), false, 'UTF-8')]
/*******************************************************************************
 * Copyright (c) 2012 IBM Corporation and others.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v. 1.0 which accompanies this distribution.
 *  
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *
 *     Russell Boykin       - initial API and implementation
 *     Alberto Giammaria    - initial API and implementation
 *     Chris Peters         - initial API and implementation
 *     Gianluca Bernardini  - initial API and implementation
 *	   Sam Padgett	       - initial API and implementation
 *     Michael Fiedler     - adapted for OSLC4J
 *     Jad El-khoury        - initial implementation of code generator (https://bugs.eclipse.org/bugs/show_bug.cgi?id=422448)
 *
 * This file is generated by org.eclipse.lyo.oslc4j.codegenerator
 *******************************************************************************/


package [javaClassPackageName(aResource) /];

import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.text.SimpleDateFormat;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import java.util.Iterator;
import javax.servlet.http.HttpServletRequest;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;

import org.eclipse.lyo.oslc4j.core.annotation.OslcAllowedValue;
import org.eclipse.lyo.oslc4j.core.annotation.OslcDescription;
import org.eclipse.lyo.oslc4j.core.annotation.OslcName;
import org.eclipse.lyo.oslc4j.core.annotation.OslcNamespace;
import org.eclipse.lyo.oslc4j.core.annotation.OslcOccurs;
import org.eclipse.lyo.oslc4j.core.annotation.OslcPropertyDefinition;
import org.eclipse.lyo.oslc4j.core.annotation.OslcRange;
import org.eclipse.lyo.oslc4j.core.annotation.OslcReadOnly;
import org.eclipse.lyo.oslc4j.core.annotation.OslcRepresentation;
import org.eclipse.lyo.oslc4j.core.annotation.OslcResourceShape;
import org.eclipse.lyo.oslc4j.core.annotation.OslcTitle;
import org.eclipse.lyo.oslc4j.core.annotation.OslcValueType;
import org.eclipse.lyo.oslc4j.core.model.AbstractResource;
import org.eclipse.lyo.oslc4j.core.model.Link;
import org.eclipse.lyo.oslc4j.core.model.Occurs;
import org.eclipse.lyo.oslc4j.core.model.OslcConstants;
import org.eclipse.lyo.oslc4j.core.model.Representation;
import org.eclipse.lyo.oslc4j.core.model.ValueType;

import [javaClassFullNameForAdaptorServletListener(aResource.eContainer(AdaptorInterface)) /]; 
import [javaInterfaceFullNameForAdaptorConstants(aResource.eContainer(AdaptorInterface)) /];
[for (aProperty: ResourceProperty | allProperties(aResource))]
[if(Sequence{'Resource', 'LocalResource'}->includes(aProperty.valueType.toString())) ]
[if (not aProperty.range.oclIsUndefined())]
import [javaClassFullName(aProperty.range) /];	
[/if]
[/if]
[/for]

// [protected ('imports')]
// [/protected]

@OslcNamespace([javaInterfaceNameForAdaptorConstants(aResource.eContainer(AdaptorInterface)) /].[domainSpecificationNamespaceConstantName(aResource.definingDomainSpecification()) /])
@OslcName([javaInterfaceNameForAdaptorConstants(aResource.eContainer(AdaptorInterface)) /].[resourceConstantName(aResource) /]) 
@OslcResourceShape(title = "[aResource.name /] Resource Shape", describes = [javaInterfaceNameForAdaptorConstants(aResource.eContainer(AdaptorInterface)) /].[resourceTypeConstantName(aResource) /])
public class [javaClassName(aResource) /]
       extends [parentJavaClassName(aResource) /]
{

[for (aProperty: ResourceProperty | aResource.resourceProperties)]
private [javaAttributeTypeDeclaration(aProperty) /] [javaAttributeName(aProperty, aResource)/][if javaAttributeTypeNeedsConstruction(aProperty)] = new [javaAttributeTypeDeclaration(aProperty)/]()[/if];  
[/for]

public [javaClassName(aResource) /]()
       throws URISyntaxException
{
    super();

	// [protected ('constructor1')]
	// [/protected]
}

public [javaClassName(aResource) /](final URI about)
       throws URISyntaxException
{
    super(about);

	// [protected ('constructor2')]
	// [/protected]
}

public static URI constructURI(String serviceProviderId, String [aResource.name.toLowerFirst() /]Id) throws URISyntaxException, UnsupportedEncodingException
{
	[comment TODO: The URI below should be constructed using the same methods that construct the "@Path" of the services.
	These are currently hard coded as well. Change that, so that both use the same source. THis way, if there is a coder-define  
	customisation of the method, the rest of the code will work fine./]
	return new URI([javaClassNameForAdaptorServletListener(aResource.eContainer(AdaptorInterface))/].getServicesBase() + "/" + serviceProviderId + "/[aResource.name.toLowerFirst() /]s/"+ [aResource.name.toLowerFirst() /]Id);
}

public String toString()
{
		String result = "";
		// [protected ('toString_init')]
		// [/protected]

		result = getAbout().toString();

		// [protected ('toString_finalize')]
		// [/protected]

		return result;
}

public String toHtml()
{
		String result = "";
		// [protected ('toHtml_init')]
		// [/protected]

		result = "<a href=\"" + getAbout() + "\">" + toString() + "</a>";

		// [protected ('toHtml_finalize')]
		// [/protected]

		return result;
}


[for (aProperty: ResourceProperty | aResource.resourceProperties)]
	[if (Sequence{'zeroOrMany', 'oneOrMany'}->includes(aProperty.occurs.toString()))]
    public void add[aProperty.name.toUpperFirst() /](final [javaAttributeBaseType(aProperty) /] [aProperty.name /] )
    {
        this.[javaAttributeName(aProperty, aResource) /].add([aProperty.name /]);
    }
	[/if]
[/for]

[for (aProperty: ResourceProperty | aResource.resourceProperties)]
   	[nameAnnotation(aProperty) /]
   	[propertyDefinitionAnnotation(aProperty, aResource) /]
	[descriptionAnnotation(aProperty) /]
	[occursAnnotation(aProperty) /]
	[valueTypeAnnotation(aProperty) /]
	[representationAnnotation(aProperty) /]
	[rangeAnnotation(aProperty, aResource) /]
	[readOnlyAnnotation(aProperty) /]
	[titleAnnotation(aProperty) /]
    public [javaAttributeTypeDeclaration(aProperty) /] [if (aProperty.valueType.toString() = 'Boolean')]is[else]get[/if][javaAttributeName(aProperty, aResource).toUpperFirst() /]()
    {
        return [javaAttributeName(aProperty, aResource) /];
    }

[/for]

[for (aProperty: ResourceProperty | aResource.resourceProperties)]
    public void set[javaAttributeName(aProperty, aResource).toUpperFirst() /](final [javaAttributeTypeDeclaration(aProperty) /] [aProperty.name /] )
    {
	[if (Sequence{'zeroOrMany', 'oneOrMany'}->includes(aProperty.occurs.toString()))]
        this.[javaAttributeName(aProperty, aResource) /].clear();
        if ([aProperty.name /] != null)
        {
            this.[javaAttributeName(aProperty, aResource) /].addAll([aProperty.name /]);
        }

	[else]
        this.[javaAttributeName(aProperty, aResource) /] = [aProperty.name /];
	[/if]
    }
[/for]

[for (aProperty: ResourceProperty | aResource.resourceProperties)]
    static public String [javaAttributeName(aProperty, aResource) /]ToHtmlForCreation (final HttpServletRequest httpServletRequest, final String serviceProviderId)
    {
		String s = "";

		// [protected (javaAttributeName(aProperty, aResource).concat('asHtmlForCreation_init'))]
		// [/protected]

		s = s + "<label for=\"[aProperty.name/]\">[aProperty.name/]: </LABEL>";

		// [protected (javaAttributeName(aProperty, aResource).concat('asHtmlForCreation_mid'))]
		// [/protected]

		[let valueType : String = aProperty.valueType.toString()]
			[if (Sequence{'String', 'XMLLiteral', 'DateTime', 'URI'}->includes(valueType))]
				s= s + [resourcePropertyAsTextInputForCreation(aProperty) /];
			[elseif(valueType = 'Boolean')]
				s= s + "<input name=\"[aProperty.name/]\" type=\"radio\" value=\"true\">True<br><input name=\"[aProperty.name/]\" type=\"radio\" value=\"false\">False";
			[elseif(Sequence{'Resource', 'LocalResource'}->includes(valueType))]
					[comment TODO: How to deal with properties that are resources? Should then also be created, or should hte user get a list of existing such resources to choose from. 
					Latter sounds most reasonable. For now just ignore such properties./]
			[/if]
		[/let]

		// [protected (javaAttributeName(aProperty, aResource).concat('asHtmlForCreation_finalize'))]
		// [/protected]

		return s; 
    }
[/for]

[comment TODO: This ToHTML is quite complicated. At the moment, I get expections because some of the properties are null.
I am getting to many if/else-ses. I think I need to rethink calmely to have a cleaner structure. Good enough for now I hope. /]
[for (aProperty: ResourceProperty | aResource.resourceProperties)]
    public String [javaAttributeName(aProperty, aResource) /]ToHtml()
    {
		String s = "";

		// [protected (javaAttributeName(aProperty, aResource).concat('toHtml_init'))]
		// [/protected]

		s = s + "<label for=\"[aProperty.name/]\"><strong>[aProperty.name/]</strong>: </LABEL>";

		// [protected (javaAttributeName(aProperty, aResource).concat('toHtml_mid'))]
		// [/protected]

		try {
		[comment For these basic valueTypes, one can simply call toString on the attribte /]
		[if (Sequence{'Boolean', 'String', 'XMLLiteral', 'DateTime', 'URI'}->includes(aProperty.valueType.toString()))]
		    [if (Sequence{'zeroOrMany', 'oneOrMany'}->includes(aProperty.occurs.toString()))]
		        s = s + "<ul>";
				Iterator<[javaAttributeBaseType(aProperty) /]> itr = [javaAttributeName(aProperty, aResource) /].iterator();
				while(itr.hasNext()) {
					s = s + "<li>";
					s= s + itr.next().toString();
					s = s + "</li>";
				}
		        s = s + "</ul>";
			[else]
				if ([javaAttributeName(aProperty, aResource)/] == null) {
					s= s + "<em>null</em>";				
				}
				else {
					s= s + [javaAttributeName(aProperty, aResource)/].toString();				
				}
		    [/if]
		[comment a property with valueType of resource or LocalResource can return either a Class directly referring to a Resource, or Link. 
		If we get a Link, we want to check if we can also work out which kind of resource class this Link refers to. If we can find out, 
		we want to call toHtml on that class. if we cannot, we simply print the Link as a string. /]
		[elseif(Sequence{'Resource', 'LocalResource'}->includes(aProperty.valueType.toString()))]
		    [if (Sequence{'zeroOrMany', 'oneOrMany'}->includes(aProperty.occurs.toString()))]
		        s = s + "<ul>";
				Iterator<[javaAttributeBaseType(aProperty) /]> itr = [javaAttributeName(aProperty, aResource) /].iterator();
				while(itr.hasNext()) {
					s = s + "<li>";
				    [if (javaAttributeBaseType(aProperty) = 'Link')]
					    [if (not aProperty.range.oclIsUndefined())]
							[comment Even if it is a Link, there are cases where I actually know that the link should point to a particular resource class.
							(For example, for valueType = Resource, we get a Link irrespective of whether the valueType is set to a specific resource or not. ) /]
							s = s + (new [javaClassName(aProperty.range) /] (itr.next().getValue())).toHtml();
						[else]
							[comment just print the Link's URI as a String /]
							s = s + itr.next().getValue().toString();
					    [/if]
					[else]
						[comment itr refers to direct Resource class, and hence can simply call toHtml() on /]
						s = s + itr.next().toHtml();
				    [/if]
					s = s + "</li>";
				}
		        s = s + "</ul>";
			[else]
			    [if (javaAttributeBaseType(aProperty) = 'Link')]
				    [if (not aProperty.range.oclIsUndefined())]
						[comment Even if it is a Link, there are cases where I actually know that the link should point to a particular resource class.
						(For example, for valueType = Resource, we get a Link irrespective of whether the valueType is set to a specific resource or not. ) /]
						s = s + (new [javaClassName(aProperty.range) /] ([javaAttributeName(aProperty, aResource)/].getValue())).toHtml();
					[else]
						[comment just print the Link's URI as a String /]
					s = s + [javaAttributeName(aProperty, aResource)/].getValue().toString();
				    [/if]

				[else]
					[comment the attribute refers to direct Resource class, and hence can simply call toHtml() on /]
					s = s + [javaAttributeName(aProperty, aResource)/].toHtml();
			    [/if]

		    [/if]
		[/if]
	    } catch (Exception e) {
	        e.printStackTrace();
	    }

		// [protected (javaAttributeName(aProperty, aResource).concat('toHtml_finalize'))]
		// [/protected]

		return s; 
    }
[/for]

}

[/file]
[/template]


[template public resourcePropertyAsTextInputForCreation(aProperty: ResourceProperty)]
"<input name=\"[aProperty.name/]\" type=\"text\" style=\"width: 400px\" id=\"[aProperty.name/]\" [if (Sequence{'excatlyOne', 'oneOrMany'}->includes(aProperty.occurs.toString()))]required[/if]>"
[/template]

