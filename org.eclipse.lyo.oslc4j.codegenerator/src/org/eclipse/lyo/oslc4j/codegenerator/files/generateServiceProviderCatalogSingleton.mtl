[comment encoding = UTF-8 /]
[comment
/*******************************************************************************
 * Copyright (c) 2012 IBM Corporation and others.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v. 1.0 which accompanies this distribution.
 *  
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *
 *     Russell Boykin       - initial API and implementation
 *     Alberto Giammaria    - initial API and implementation
 *     Chris Peters         - initial API and implementation
 *     Gianluca Bernardini  - initial API and implementation
 *     Michael Fiedler      - adapted for Bugzilla service provider
 *     Jad El-khoury        - initial implementation of code generator (https://bugs.eclipse.org/bugs/show_bug.cgi?id=422448)
 *     Matthieu Helleboid   - initialize each service provider separately
 *	   						- Use of Adapator Interface Generator
 *							- Add 2 empty template that can be overriden to add new import and new methods
 *							- Move constructServiceProviderURI to ServiceProviderInfo
 *							- Use independent from service provider methods with varargs
 *     Anass Radouani       - initialize each service provider separately
 *							- Extract import and initServicePorivders method to templates
 *	   						- Use of Adapator Interface Generator
 *							- Add 2 empty template that can be overriden to add new import and new methods
 *							- Extract import and initServicePorivders method to templates
 *							- Move constructServiceProviderURI to ServiceProviderInfo
 *							- Use independent from service provider methods with varargs
 *******************************************************************************/
/]

[module generateServiceProviderCatalogSingleton('http://org.eclipse.lyo/oslc4j/adaptorInterface', 'http://org.eclipse.lyo/oslc4j/adaptorInterfaceGenerator')]

[import org::eclipse::lyo::oslc4j::codegenerator::services::services/]
[import org::eclipse::lyo::oslc4j::codegenerator::services::serviceProviderCatalogServices/]
[import org::eclipse::lyo::oslc4j::codegenerator::services::adaptorInterfaceServices/]
[import org::eclipse::lyo::oslc4j::codegenerator::services::serviceProviderServices/]

[template public generateServiceProviderCatalogSingleton(anAdaptorInterfaceGenerator : AdaptorInterfaceGenerator, aServiceProviderCatalog : ServiceProviderCatalog)]
[file (javaClassFullFileNameForSingleton(aServiceProviderCatalog, anAdaptorInterfaceGenerator), false, 'UTF-8')]
/*******************************************************************************
 * Copyright (c) 2012 IBM Corporation and others.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v. 1.0 which accompanies this distribution.
 *  
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *
 *     Russell Boykin       - initial API and implementation
 *     Alberto Giammaria    - initial API and implementation
 *     Chris Peters         - initial API and implementation
 *     Gianluca Bernardini  - initial API and implementation
 *     Michael Fiedler      - adapted for Bugzilla service provider
 *     Jad El-khoury        - initial implementation of code generator (https://bugs.eclipse.org/bugs/show_bug.cgi?id=422448)
 *     Matthieu Helleboid   - initialize each service provider separately
 *							- Move constructServiceProviderURI to ServiceProviderInfo
 *							- Use independent from service provider methods with varargs
 *     Anass Radouani       - initialize each service provider separately
 *							- Move constructServiceProviderURI to ServiceProviderInfo
 *							- Use independent from service provider methods with varargs
 *
 * This file is generated by org.eclipse.lyo.oslc4j.codegenerator
 *******************************************************************************/

package [javaClassPackageNameForSingleton(aServiceProviderCatalog, anAdaptorInterfaceGenerator) /];

import java.net.URI;
import java.net.URISyntaxException;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;

import javax.servlet.http.HttpServletRequest;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Response.Status;

import org.eclipse.lyo.oslc4j.client.ServiceProviderRegistryURIs;
import org.eclipse.lyo.oslc4j.core.model.Publisher;
import org.eclipse.lyo.oslc4j.core.model.Service;
import org.eclipse.lyo.oslc4j.core.model.ServiceProvider;
import org.eclipse.lyo.oslc4j.core.model.ServiceProviderCatalog;

import [javaClassFullNameForAdaptorManager(anAdaptorInterfaceGenerator) /];
[importServiceProvidersInfos(aServiceProviderCatalog, anAdaptorInterfaceGenerator)/]
[comment Override to add extra imports /]
[getExtraImports(aServiceProviderCatalog, anAdaptorInterfaceGenerator)/]

// [protected ('imports')]
// [/protected]


/**
 * This is the OSLC service provider catalog for the Bugzilla adapter.  Service providers are
 * not registered with the catalog until a request comes in to access either the catalog or a 
 * specific service provider.   This request could be from an external consumer or an internal
 * request triggered by a consumer accessing a change request.
 * 
 * The service providers are created and registered in the initServiceProvidersFromProducts()
 * method.  A list of accessible products is retrieved from Bugzilla and a ServiceProvider is
 * created and registered for each using the Bugzilla productId as the identifier.
 * 
 * The registered service providers are refreshed on each catalog or service provider collection
 * request.
 */
public class [javaClassNameForSingleton(aServiceProviderCatalog) /]
{
    private static final ServiceProviderCatalog             serviceProviderCatalog;
	[comment TODO: We here assume that 1 single serviceProvider type is specified in the SPCatalog.
	In the metamodel, a SPCatalog  can have 1+ serviceProvider types. 
	For example, one SP type maps to the products. Another SP type maps to "something-else".
	In this case, each such SP type would need to define its name. (for example "ProductServiceProvider")
	In this case, loop through the SP types, and create a variable for each. You will also need to loop through and create the functions below for each such SP type. 
	Alternatively, define serviceProviders as some Dictionary, where the key is the SP name, and the value is the SortedMap below/]
    private static final SortedMap<String, ServiceProvider> serviceProviders = new TreeMap<String, ServiceProvider>();

    static
    {
        try
        {
            serviceProviderCatalog = new ServiceProviderCatalog();

            serviceProviderCatalog.setAbout(new URI(ServiceProviderRegistryURIs.getServiceProviderRegistryURI()));
            serviceProviderCatalog.setTitle("[aServiceProviderCatalog.title /]");
            serviceProviderCatalog.setDescription("[aServiceProviderCatalog.description /]");
            serviceProviderCatalog.setPublisher(new Publisher("[aServiceProviderCatalog.publisher.title /]", "[aServiceProviderCatalog.publisher.identifier /]"));
            serviceProviderCatalog.getPublisher().setIcon(new URI("[aServiceProviderCatalog.publisher.icon /]"));
        }
        catch (final URISyntaxException exception)
        {
            // We should never get here.
            throw new ExceptionInInitializerError(exception);
        }
    }


    private [javaClassNameForSingleton(aServiceProviderCatalog) /]()
    {   	
        super();
    }
    

    public static URI getUri()
    {
    	return serviceProviderCatalog.getAbout();
    }

    public static ServiceProviderCatalog getServiceProviderCatalog(HttpServletRequest httpServletRequest) 
    {
    	initServiceProviders(httpServletRequest);
        return serviceProviderCatalog;
    }

    public static ServiceProvider [ '[' ']' /] getServiceProviders(HttpServletRequest httpServletRequest) 
    {
        synchronized(serviceProviders)
        {
        	initServiceProviders(httpServletRequest);
            return serviceProviders.values().toArray(new ServiceProvider[ '[' /] serviceProviders.size()[ ']' /]);
        }
    }

    private static String serviceProviderIdentifier(final String... serviceProviderIds)
    {
		String identifier = "" ;
        
        for (String serviceProviderId : serviceProviderIds) {
			identifier += "/" + serviceProviderId;
		}
        
        return identifier;
    }

    public static ServiceProvider getServiceProvider(HttpServletRequest httpServletRequest, final String... serviceProviderIds) 
    {
        ServiceProvider serviceProvider;

        synchronized(serviceProviders)
        {     	
            String identifier = serviceProviderIdentifier(serviceProviderIds);
            serviceProvider = serviceProviders.get(identifier);
            
            //One retry refreshing the service providers
            if (serviceProvider == null)
            {
            	getServiceProviders(httpServletRequest);
            	serviceProvider = serviceProviders.get(identifier);
            }
        }

        if (serviceProvider != null)
        {
            return serviceProvider;
        }

        throw new WebApplicationException(Status.NOT_FOUND);
    }

    public static ServiceProvider registerServiceProvider(final HttpServletRequest httpServletRequest,
                                                          final ServiceProvider    serviceProvider,
                                                          final URI serviceProviderURI,
                                                          final String... serviceProviderIds) 
                                                throws URISyntaxException
    {
        synchronized(serviceProviders)
        {
            return registerServiceProviderNoSync(serviceProviderURI,
                                                 serviceProvider,
                                                 serviceProviderIds);
        }
    }


/**
 * Register a service provider with the OSLC catalog
 * 
 * @param serviceProviderURI
 * @param serviceProvider
 * @param productId
 * @return
 */
    private static ServiceProvider registerServiceProviderNoSync(final URI             serviceProviderURI,
                                                                 final ServiceProvider serviceProvider,
                                                                 final String... serviceProviderIds)
    {
        final SortedSet<URI> serviceProviderDomains = getServiceProviderDomains(serviceProvider);

        String identifier = serviceProviderIdentifier(serviceProviderIds);
        serviceProvider.setAbout(serviceProviderURI);
        serviceProvider.setIdentifier(identifier);
        serviceProvider.setCreated(new Date());
        serviceProvider.setDetails(new URI[ '[' ']' /] {serviceProviderURI});

        serviceProviderCatalog.addServiceProvider(serviceProvider);
        serviceProviderCatalog.addDomains(serviceProviderDomains);

        serviceProviders.put(identifier, serviceProvider);

        return serviceProvider;
    }
    
    // This version is for self-registration and thus package-protected
    static ServiceProvider registerServiceProvider(final ServiceProvider serviceProvider,
													final URI serviceProviderURI,
													final String... serviceProviderIds)
                                            throws URISyntaxException
    {
        synchronized(serviceProviders)
        {
            return registerServiceProviderNoSync(serviceProviderURI, serviceProvider, serviceProviderIds);
        }
    }

    public static void deregisterServiceProvider(final String... serviceProviderIds)
    {
        synchronized(serviceProviders)
        {
            final ServiceProvider deregisteredServiceProvider = serviceProviders.remove(serviceProviderIdentifier(serviceProviderIds));

            if (deregisteredServiceProvider != null)
            {
                final SortedSet<URI> remainingDomains = new TreeSet<URI>();

                for (final ServiceProvider remainingServiceProvider : serviceProviders.values())
                {
                    remainingDomains.addAll(getServiceProviderDomains(remainingServiceProvider));
                }

                final SortedSet<URI> removedServiceProviderDomains = getServiceProviderDomains(deregisteredServiceProvider);

                removedServiceProviderDomains.removeAll(remainingDomains);
                serviceProviderCatalog.removeDomains(removedServiceProviderDomains);
                serviceProviderCatalog.removeServiceProvider(deregisteredServiceProvider);
            }
            else
            {
                throw new WebApplicationException(Status.NOT_FOUND);
            }
        }
    }

    private static SortedSet<URI> getServiceProviderDomains(final ServiceProvider serviceProvider)
    {
        final SortedSet<URI> domains = new TreeSet<URI>();

        if (serviceProvider!=null) {
    		final Service [ '[' ']' /] services = serviceProvider.getServices();
	        for (final Service service : services)
	        {
	            final URI domain = service.getDomain();

	            domains.add(domain);
	        }
        }
        return domains;
    }
    
    /**
     * Retrieve a list of products from Bugzilla and construct a service provider for each.
     * 
     * Each product ID is added to the parameter map which will be used during service provider
     * creation to create unique URI paths for each Bugzilla product.  See @Path definition at
     * the top of BugzillaChangeRequestService.
     * 
     * @param httpServletRequest
     */
    protected static void initServiceProviders (HttpServletRequest httpServletRequest)   
    {
		try {

			// [protected ('initServiceProviders')]
			// [/protected]

	        String basePath = [javaClassNameForAdaptorServletListener(containingAdaptorInterface(aServiceProviderCatalog)) /].getServicesBase();

			[initServiceProviders(aServiceProviderCatalog)/]

		} catch (Exception e) {
			e.printStackTrace();
			throw new WebApplicationException(e,Status.INTERNAL_SERVER_ERROR);
		}
    }

	[comment Override this template to add extra methods/]
	[getExtraMethods(aServiceProviderCatalog, anAdaptorInterfaceGenerator)/]

}

[/file]
[/template]

[template public importServiceProvidersInfos(aServiceProviderCatalog : ServiceProviderCatalog, anAdaptorInterfaceGenerator : AdaptorInterfaceGenerator)]
[for (aServiceProvider: ServiceProvider | aServiceProviderCatalog.serviceProviders)]
import [javaClassFullNameForServiceProviderInfo(aServiceProvider, anAdaptorInterfaceGenerator) /];
[/for]
[/template]

[template public initServiceProviders(aServiceProviderCatalog : ServiceProviderCatalog)]
[for (aServiceProvider: ServiceProvider | aServiceProviderCatalog.serviceProviders)]
[javaClassNameForServiceProviderInfo(aServiceProvider) /] [ '[' ']' /] serviceProviderInfos['For'.concat(aServiceProvider.title.substituteAll(' ','').toUpperFirst())/] = [javaClassNameForAdaptorManager(containingAdaptorInterface(aServiceProviderCatalog)) /].getServiceProviderInfos['For'.concat(aServiceProvider.title.replaceAll(' ','').toUpperFirst())/](httpServletRequest);
//Register a service provider for each serviceProviderInfo
for ([javaClassNameForServiceProviderInfo(aServiceProvider) /] serviceProviderInfo : serviceProviderInfos['For'.concat(aServiceProvider.title.substituteAll(' ','').toUpperFirst())/]) {
	String identifier = serviceProviderIdentifier([for (instanceCompositeID: String | instanceCompositeID(aServiceProvider)) separator(', ')]serviceProviderInfo.[instanceCompositeID /][/for]);
    if (! serviceProviders.containsKey(identifier)) {
		String serviceProviderName = serviceProviderInfo.name;
		String title = "[aServiceProvider.title.concat(': ') /]" + serviceProviderName + "(" + identifier + ")";
		String description = "[aServiceProvider.description.concat(': ') /]" + serviceProviderName + "(" + identifier + ")";
		Publisher publisher = new Publisher("[aServiceProvider.publisher.title /]", "[aServiceProvider.publisher.identifier /]");
    	Map<String, Object> parameterMap = new HashMap<String, Object>();
        [for (instanceCompositeID: String | instanceCompositeID(aServiceProvider)) separator(lineSeparator())]
        parameterMap.put("[instanceCompositeID /]", serviceProviderInfo.[instanceCompositeID /]);
        [/for]
    	final ServiceProvider aServiceProvider = [javaClassNameForServiceProviderFactory(aServiceProvider) /].createServiceProvider(basePath, title, description, publisher, parameterMap);
		registerServiceProvider(aServiceProvider, [javaClassNameForServiceProviderInfo(aServiceProvider) /].constructServiceProviderURI([aServiceProvider.instanceMethodParameterList('serviceProviderInfo')/]), [for (instanceCompositeID: String | instanceCompositeID(aServiceProvider)) separator(', ')]serviceProviderInfo.[instanceCompositeID /][/for]);
	}
}
[/for]
[/template]

[comment Override to add extra imports /]
[template public getExtraImports(aServiceProviderCatalog : ServiceProviderCatalog, anAdaptorInterfaceGenerator : AdaptorInterfaceGenerator)]
[/template]

[comment Override this template to add extra methods/]
[template public getExtraMethods(aServiceProviderCatalog : ServiceProviderCatalog, anAdaptorInterfaceGenerator : AdaptorInterfaceGenerator)]
[/template]

